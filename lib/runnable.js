//TODO: Not all events are wired up!
/**
 * Module dependencies.
 */

var EventEmitter = require('events').EventEmitter
  , debug = require('debug')('mocha:runnable')
  , milliseconds = require('./ms')
  , domain = require('domain')

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date
  , setTimeout = global.setTimeout
  , setInterval = global.setInterval
  , clearTimeout = global.clearTimeout
  , clearInterval = global.clearInterval;

/**
 * Object#toString().
 */

var toString = Object.prototype.toString;

/**
 * Initialize a new Runnable with the given title and callback fn
 *
 * @param {String} title Title of this runnable
 * @param {function} fn Function to run for this runnable
 *
 * @constructor
 */
var Runnable = function (title, fn) {
    this.title = title
    this.fn = fn
    this.async = fn && fn.length
    this.sync = ! this.async
    this.err = false
    this.completed = false
    this.timedOut = false

    this.dependants = []
    this._exclusive = false
    this._timeout = 2000
    this._slow = 75
    this._dependencies = []
    this._complete_dependencies = 0
}

/**
 * Inherit from `EventEmitter.prototype`.
 */
Runnable.prototype.__proto__ = EventEmitter.prototype;

/**
 * Expose `Runnable`.
 */
module.exports = Runnable;

/**
 * Set & get timeout `ms`.
 *
 * @param {Number|String} ms
 * @return {Runnable|Number} ms or self
 * @api private
 */

Runnable.prototype.timeout = function(ms){
  if (0 == arguments.length) return this._timeout;
  if ('string' == typeof ms) ms = milliseconds(ms);
  debug('timeout %d', ms);
  this._timeout = ms;
  if (this.timer) this.resetTimeout();
  return this;
};

Runnable.prototype.exclusive = function(exclusive) {
    if (0 == arguments.length) {
        return this._exclusive
    }

    this._exclusive = exclusive
    return this
};

/**
 * Set & get slow `ms`.
 *
 * @param {Number|String} ms
 * @return {Runnable|Number} ms or self
 * @api private
 */

Runnable.prototype.slow = function(ms){
  if (0 === arguments.length) return this._slow;
  if ('string' == typeof ms) ms = milliseconds(ms);
  debug('timeout %d', ms);
  this._slow = ms;
  return this;
};

/**
 * Return the full title generated by recursively
 * concatenating the parent's full title.
 *
 * @param {String} [separator=' '] The string that will separate each parent
 *
 * @return {String}
 *
 * @api public
 */
Runnable.prototype.fullTitle = function (separator) {
    var title = this.title

    if (this._exclusive) {
        title = 'EX ' + title
    }

    if (!this.parent) {
        return title
    }

    separator = separator || ' '
    return this.parent.fullTitle(separator) + separator + title;
};

/**
 * Clear the timeout.
 *
 * @api private
 */

Runnable.prototype.clearTimeout = function(){
  clearTimeout(this.timer);
};

/**
 * Inspect the runnable void of private properties.
 *
 * @return {String}
 * @api private
 */

Runnable.prototype.inspect = function(){
  return JSON.stringify(this, function(key, val){
    if ('_' == key[0]) return;
    if ('parent' == key) return '#<Suite>';
    if ('ctx' == key) return '#<Context>';
    return val;
  }, 2);
};

/**
 * Reset the timeout.
 *
 * @api private
 */

Runnable.prototype.resetTimeout = function(){
  var self = this
    , ms = this.timeout();

  this.clearTimeout();
  if (ms) {
    this.timer = setTimeout(function(){
      self.callback(new Error('timeout of ' + ms + 'ms exceeded'));
      self.timedOut = true;
    }, ms);
  }
};

Runnable.prototype.add_dependencies = function (dependencies) {
    var self = this

    dependencies.forEach(function (dependency) {
        dependency.dependants.push(self)

        self._dependencies.push(dependency)

        dependency.on('completed', function (dependency) {
            self._dependency_completed(dependency)
        })

        dependency.on('error', function (dependency) {
            self._dependency_completed(dependency)
        })
    })
}

Runnable.prototype._dependency_completed = function (dependency) {
    //TODO: if the dependency double emits we are in trouble with this
    this._complete_dependencies++
    this.run()
}

/**
 * Run the test
 */
Runnable.prototype.run = function(){
    var self = this
      , ms = self.timeout()
      , start = new Date
      , ctx = self.ctx
      , multiple_emitted
      , test_domain

    //TODO: Need better detection of this case
    if (this._complete_dependencies < this._dependencies.length) {
        return
    }

    test_domain = domain.create()
    test_domain.on('error', function (err) {
        done(err)
    })

    if (ctx) {
        ctx.runnable(self)
    }

    self.emit('started', self)

    // timeout
    if (self.async && ms) {
        self.timer = setTimeout(function () {
            self.timedOut = true
            done(new Error('timeout of ' + ms + 'ms exceeded'))
        }, ms)
    }

    // called multiple times
    function multiple (err) {
        if (multiple_emitted) {
            return
        }

        multiple_emitted = true
        self.emit('error', err || new Error('done() called multiple times'))
    }

    // finished
    function done (err) {
        if (self.completed) {
            if (self.timedOut) {
                return
            }

            return multiple(err)
        }

        if (err && ((err instanceof Error) === false || toString.call(err) !== "[object Error]")) {
            err = new Error('done() invoked with non-Error: ' + JSON.stringify(err))
        }

        self.err = err

        self.clearTimeout()
        self.duration = new Date - start
        self.completed = true

        self.emit('completed', self)
    }

    function handlePromise(retVal) {
        if (typeof retVal !== "object" || retVal === null || typeof retVal.then !== "function") {
            return false;
        }

        retVal.then(
            function () {
                done()
            }
          , function (reason) {
                if (reason === null || reason === undefined) {
                    reason = new Error("Promise rejected with no rejection reason.")
                }

                done(reason)
            }
        )

        return true
    }

    // for .resetTimeout()
    self.callback = done

    // async
    if (self.async) {
        test_domain.run(function () {
            try {
                var retVal = self.fn.call(ctx, done)
                handlePromise(retVal)

            } catch (err) {
                done(err)
            }
        })

        return
    }

    if (self.asyncOnly) {
        return done(new Error('--async-only option in use without declaring `done()`'))
    }

    // sync
    test_domain.run(function () {
        try {

            if (!self.pending) {
                // If we get a promise back exit early
                if (handlePromise(self.fn.call(ctx))) {
                    return
                }
            }

            done()

        } catch (err) {
            done(err)
        }
    })
};
