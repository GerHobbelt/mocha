//TODO: Not all events are wired up!

var EventEmitter = require('events').EventEmitter
  , debug = require('debug')('mocha:runnable')
  , milliseconds = require('./ms')
  , domain = require('domain')

/**
 * Save timer references to avoid Sinon interfering
 */
var Date = global.Date
  , setTimeout = global.setTimeout
  , setInterval = global.setInterval
  , clearTimeout = global.clearTimeout
  , clearInterval = global.clearInterval

/**
 * Initialize a new Runnable with the given title and callback function
 *
 * @param {String} title Title of this runnable
 * @param {function} test_function Function to run for this runnable
 *
 * @constructor
 */
var Runnable = function (title, test_function) {
    this.title = title
    this.test_function = test_function
    this.async = test_function && test_function.length
    this.errors = []
    this.run_state = Runnable.STATE_WAITING
    this.timed_out = false
    this.dependants = []
    this.skipped = !test_function

    this._exclusive = false
    this._timeout = 2000
    this._slow = 75
    this._dependencies = []
    this._complete_dependencies = 0
}

Runnable.prototype.__proto__ = EventEmitter.prototype
module.exports = Runnable

Runnable.STATE_WAITING = 1
Runnable.STATE_RUNNING = 2
Runnable.STATE_COMPLETED = 3

/**
 * Clones a runnable
 *
 * @returns {Runnable} The new runnable cloned from this runnable
 */
Runnable.prototype.clone = function () {
    var runnable = new Runnable(this.title, this.test_function)
    runnable.timeout(this.timeout())
    runnable.exclusive(this.exclusive())
    runnable.slow(this.slow())
    runnable.type = this.type
    return runnable
}

/**
 * Set & get timeout `ms`.
 *
 * @param {Number|String} ms
 * @return {Runnable|Number} ms or self
 * @api private
 */
Runnable.prototype.timeout = function (ms) {
    if (0 == arguments.length) {
        return this._timeout
    }

    if ('string' == typeof ms) {
        ms = milliseconds(ms)
    }

    this._timeout = ms
    if (this.timer) {
        this.reset_timeout()
    }

    return this
}

/**
 * Set & get exclusive value
 * If a test is exclusive then no other test can run during its execution, exclusive tests slow everything down
 *
 * @param {boolean|undefined} exclusive True or false to set exclusivity or undefined to get the value
 *
 * @returns {boolean|Runnable} Either the boolean for exclusivity or this for chaining
 */
Runnable.prototype.exclusive = function (exclusive) {
    if (0 == arguments.length) {
        return this._exclusive
    }

    this._exclusive = exclusive
    return this
}

/**
 * Set & get slow `ms`.
 *
 * @param {Number|String} ms
 * @return {Runnable|Number} ms or self
 * @api private
 */
Runnable.prototype.slow = function(ms){
    if (0 === arguments.length) {
        return this._slow
    }

    if ('string' == typeof ms) {
        ms = milliseconds(ms)
    }

    this._slow = ms
    return this
}

/**
 * Return the full title generated by recursively
 * concatenating the parent's full title.
 *
 * @param {String} [separator=' '] The string that will separate each parent
 *
 * @return {String}
 *
 * @api public
 */
Runnable.prototype.fullTitle = function (separator) {
    var title = this.title

    if (!this.parent) {
        return title
    }

    separator = separator || ' '
    return this.parent.fullTitle(separator) + separator + title
}

/**
 * Clear the timeout.
 *
 * @api private
 */
Runnable.prototype.clear_timeout = function(){
    clearTimeout(this.timer)
}

/**
 * Reset the timeout.
 *
 * @api private
 */
Runnable.prototype.reset_timeout = function () {
    var self = this
      , ms = this.timeout()

    this.clear_timeout()
    if (ms) {
        this.timer = setTimeout(function(){
            self.complete(new Error('timeout of ' + ms + 'ms exceeded'))
            self.timed_out = true
        }, ms)
    }
}

/**
 * Adds a list of dependencies to this test
 *
 * @param {Array.<Runnable>} dependencies An array of runnable dependencies to add to this test
 */
Runnable.prototype.add_dependencies = function (dependencies) {
    var self = this

    dependencies.forEach(function (dependency) {
        dependency.dependants.push(self)

        self._dependencies.push(dependency)

        dependency.on('completed', function (dependency) {
            self._dependency_completed(dependency)
        })

        dependency.on('error', function (dependency) {
            self._dependency_completed(dependency)
        })
    })
}

/**
 * Marks a dependency as completed once it has completed
 *
 * @param {Runnable} dependency The completed dependency
 *
 * @private
 */
Runnable.prototype._dependency_completed = function (dependency) {
    //TODO: if the dependency double emits we are in trouble with this
    this._complete_dependencies++

    //TODO: Need better detection of this case
    if (this._complete_dependencies < this._dependencies.length) {
        return
    }

    this.run()
}

/**
 * Run the test
 */
Runnable.prototype.run = function () {
    var self = this
      , context = self.parent.context()

    self.domain = domain.create()
    self.start = Date.now()
    self.run_state = Runnable.STATE_RUNNING

    if (self.skipped) {
        return self.complete()
    }

    self.domain.on('error', function (error) {
        self.complete(error)
    })

    self.emit('started')

    self.domain.run(function () {
        try {
            self.reset_timeout()

            var return_values = self.test_function.call(context, function (error) { self.complete(error) })

            if (self._handle_promise(return_values)) {
                return
            }

            if (!self.async) {
                return self.complete()
            }

        } catch (error) {
            return self.complete(error)
        }
    })
}

/**
 * Completes the test
 *
 * @param {*} [error] An error, if there was one, to record for the test
 */
Runnable.prototype.complete = function (error) {
    var self = this

    function add_error (err) {
        if (err instanceof Error === false && err.toString() !== "[object Error]") {
            err = new Error('done() invoked with non-Error: ' + JSON.stringify(err))
        }

        self.errors.push(err)
    }

    if (self.run_state === Runnable.STATE_COMPLETED) {
        if (self.timed_out) {
            return
        }

        self.errors.push(error || new Error('done() called multiple times'))
        return
    }

    if (error) {
        add_error(error)
    }

    self.clear_timeout()
    self.duration = new Date - this.start
    self.run_state = Runnable.STATE_COMPLETED
    self.emit('completed', this)
}

/**
 * Checks the return value from running the test for a promise and handles it if necessary
 *
 * @param {*} return_value The return value of the test function
 *
 * @returns {boolean} True if the tests return value was a promise, false if not
 *
 * @private
 */
Runnable.prototype._handle_promise = function (return_value) {
    var self = this

    if (typeof return_value !== "object" || return_value === null || typeof return_value.then !== "function") {
        return false
    }

    return_value.then(
        function () {
            self.complete()
        }
        , function (reason) {
            if (reason === null || reason === undefined) {
                reason = new Error("Promise rejected with no rejection reason.")
            }

            self.complete(reason)
        }
    )

    return true
}
