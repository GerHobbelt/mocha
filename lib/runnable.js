//TODO: Not all events are wired up!

var EventEmitter = require('events').EventEmitter
  , debug = require('debug')('mocha:runnable')
  , milliseconds = require('./ms')
  , domain = require('domain')

/**
 * Save timer references to avoid Sinon interfering
 */
var Date = global.Date
  , setTimeout = global.setTimeout
  , setInterval = global.setInterval
  , clearTimeout = global.clearTimeout
  , clearInterval = global.clearInterval

/**
 * Initialize a new Runnable with the given title and callback fn
 *
 * @param {String} title Title of this runnable
 * @param {function} fn Function to run for this runnable
 *
 * @constructor
 */
var Runnable = function (title, fn) {
    this.title = title
    this.fn = fn
    this.async = fn && fn.length
    this.sync = !this.async
    this.err = false
    this.completed = false
    this.timed_out = false
    this.dependants = []
    this._pending = !fn

    this._multiple_emitted = false
    this._exclusive = false
    this._timeout = 2000
    this._slow = 75
    this._dependencies = []
    this._complete_dependencies = 0
}

Runnable.prototype.__proto__ = EventEmitter.prototype
module.exports = Runnable

Runnable.prototype.clone = function () {
    var runnable = new Runnable(this.title, this.fn)
    runnable.timeout(this.timeout())
    runnable.exclusive(this.exclusive())
    runnable.slow(this.slow())
    runnable.type = this.type
    return runnable
}

/**
 * Set & get timeout `ms`.
 *
 * @param {Number|String} ms
 * @return {Runnable|Number} ms or self
 * @api private
 */
Runnable.prototype.timeout = function(ms){
    if (0 == arguments.length) {
        return this._timeout
    }

    if ('string' == typeof ms) {
        ms = milliseconds(ms)
    }

    this._timeout = ms
    if (this.timer) {
        this.resetTimeout()
    }

    return this
}

Runnable.prototype.exclusive = function (exclusive) {
    if (0 == arguments.length) {
        return this._exclusive
    }

    this._exclusive = exclusive
    return this
}

/**
 * Set & get slow `ms`.
 *
 * @param {Number|String} ms
 * @return {Runnable|Number} ms or self
 * @api private
 */
Runnable.prototype.slow = function(ms){
    if (0 === arguments.length) {
        return this._slow
    }

    if ('string' == typeof ms) {
        ms = milliseconds(ms)
    }

    this._slow = ms
    return this
}

/**
 * Return the full title generated by recursively
 * concatenating the parent's full title.
 *
 * @param {String} [separator=' '] The string that will separate each parent
 *
 * @return {String}
 *
 * @api public
 */
Runnable.prototype.fullTitle = function (separator) {
    var title = this.title

    if (!this.parent) {
        return title
    }

    separator = separator || ' '
    return this.parent.fullTitle(separator) + separator + title
}

/**
 * Clear the timeout.
 *
 * @api private
 */
Runnable.prototype.clearTimeout = function(){
    clearTimeout(this.timer)
}

Runnable.prototype.parents = function () {
    var parent = this
      , parents = []

    while (parent && (parent = parent.parent)) {
        parents.push(parent)
    }

    return parents
}

Runnable.prototype.pending = function (pending) {
    if (0 === arguments.length) {
        if (this._pending) {
            return this._pending
        } else if (this.parent) {
            return this.parent.pending()
        }
    }

    this._pending = pending
}

/**
 * Reset the timeout.
 *
 * @api private
 */
Runnable.prototype.resetTimeout = function(){
    var self = this
      , ms = this.timeout()

    this.clearTimeout()
    if (ms) {
        this.timer = setTimeout(function(){
            self.callback(new Error('timeout of ' + ms + 'ms exceeded'))
            self.timed_out = true
        }, ms)
    }
}

Runnable.prototype.add_dependencies = function (dependencies) {
    var self = this

    dependencies.forEach(function (dependency) {
        dependency.dependants.push(self)

        self._dependencies.push(dependency)

        dependency.on('completed', function (dependency) {
            self._dependency_completed(dependency)
        })

        dependency.on('error', function (dependency) {
            self._dependency_completed(dependency)
        })
    })
}

Runnable.prototype._dependency_completed = function (dependency) {
    //TODO: if the dependency double emits we are in trouble with this
    this._complete_dependencies++

    //TODO: Need better detection of this case
    if (this._complete_dependencies < this._dependencies.length) {
        return
    }

    this.run()
}

/**
 * Run the test
 */
Runnable.prototype.run = function (callback) {
    var self = this
      , ms = self.timeout()
      , start = new Date
      , context = self.parent.context()
      , test_domain

    callback = callback || function () {}

    if (self.pending()) {
        return done()
    }

    test_domain = domain.create()
    test_domain.on('error', function (err) {
        done(err)
    })

    self.emit('started')

    // timeout
    if (self.async && ms) {
        self.timer = setTimeout(function () {
            self.timed_out = true
            console.log('^&^^^^^^^^^^^^^^^^^ TIMEOUT MOTHER FUCKER', self.title)
            done(new Error('timeout of ' + ms + 'ms exceeded'))
        }, ms)
    }

    // called multiple times
    function multiple (err) {
        console.log(err)
        if (self._multiple_emitted) {
            return
        }

        self._multiple_emitted = true
        self.emit('error', err || new Error('done() called multiple times'))
    }

    // finished
    function done (error) {
        //TODO: We can put a lot of things back on the object so that this only runs once
        if (self.completed) {
            if (self.timed_out) {
                return
            }

            return multiple(error)
        }

        self.clearTimeout()
        self.duration = new Date - start
        self.completed = true

        if (error && (error instanceof Error) === false && error.toString() !== "[object Error]") {
            error = new Error('done() invoked with non-Error: ' + JSON.stringify(error))
        }

        //console.log(error)
        self.err = error
        self.emit('completed', self)
        callback(error)
    }

    function handlePromise(retVal) {
        if (typeof retVal !== "object" || retVal === null || typeof retVal.then !== "function") {
            return false
        }

        retVal.then(
            function () {
                done()
            }
            , function (reason) {
                if (reason === null || reason === undefined) {
                    reason = new Error("Promise rejected with no rejection reason.")
                }

                done(reason)
            }
        )

        return true
    }

    // for .resetTimeout()
    self.callback = done

    // async
    if (self.async) {
        test_domain.run(function () {
            try {
                var retVal = self.fn.call(context, done)
                handlePromise(retVal)

            } catch (err) {
                done(err)
            }
        })

        return
    }

    if (self.asyncOnly) {
        return done(new Error('--async-only option in use without declaring `done()`'))
    }

    // sync
    test_domain.run(function () {
        try {

            if (!self.pending()) {
                // If we get a promise back exit early
                if (handlePromise(self.fn.call(context))) {
                    return
                }
            }

            done()

        } catch (err) {
            done(err)
        }
    })
}
